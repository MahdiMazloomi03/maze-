# -*- coding: utf-8 -*-
"""maze-local-beam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WrqnZDl_IRDwd2z__uBQ_vLSygZgypUB
"""


def is_valid_move(maze, row, col):
    return 0 <= row < len(maze) and 0 <= col < len(maze[0]) and maze[row][col] == 0

def get_neighbors(row, col):
    return [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]

def local_beam_search(maze, goal_row, goal_col, beam_width=4, max_iterations=10000):
    start_state = [(0, 0)]
    current_states = [start_state]

    for iteration in range(max_iterations):
        next_states = []

        for state in current_states:
            current_row, current_col = state[-1]

            if current_row == goal_row and current_col == goal_col:
                return state  # Goal reached

            for neighbor_row, neighbor_col in get_neighbors(current_row, current_col):
                if is_valid_move(maze, neighbor_row, neighbor_col):
                    next_states.append(state + [(neighbor_row, neighbor_col)])

        next_states.sort(key=lambda x: heuristic(x[-1], (goal_row, goal_col)))
        current_states = next_states[:beam_width]

    return None

def heuristic(current, goal):
    return abs(current[0] - goal[0]) + abs(current[1] - goal[1])

maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0]
]

goal_row, goal_col = 4, 3
path = local_beam_search(maze, goal_row, goal_col)

if path:
    print("Shortest path found:", path)
else:
    print("Goal not reached.")
